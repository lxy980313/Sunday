# 1.并发和并行
    1.并发：同一时间段内发生，可以理解为在一段时间内单cpu执行多个任务，这些任务交替执行
    2.并行：同一时刻发生（同时发生），有多个CPU，每个CPU只执行一个任务，并且执行的开始时间相同
# 2.进程和线程
    1.进程：指的是一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个程序可以同时拥有多个进程，可以理解为用电脑打开了多个相同的程序；进程是程序的一次执行过程，是操作系统运行程序的基本单位；系统运行一个程序是一个进程从创建、运行到消亡的过程。
    2.线程：线程是进程中的一个执行单元，每个进程至少有一个线程，
            举个例子，运行腾讯电脑管家程序后，就有一个进程，这个应用里有很多功能，比如查杀病毒，清理文档，电脑加速等，每个功能都是由代码编写，
           假如我同时启动这些功能，就会开启执行路劲到CPU，CPU会根据路劲来执行这些功能，这个路劲就是线程
# 3.程序的执行过程
    1.程序的内容存放在硬盘中（ROM）
    2.点击运行程序时，程序进入内存（进入到内存的程序叫进程）
# 4.线程调度
    1.分时调度：CPU平均分配执行时间
    2.抢占式调度：优先让优先级高的线程执行
# 5.主线程（单线程）
    执行主方法(main)的线程
    单线程程序：只有一个线程的程序,从main方法开始，从上到下依次执行,当线程碰到异常时就会终止异常后面的代码执行
见Thread.MainThread;
# 6.多线程
    创建多线程有两重方法：
    1.将类申明继承Thread类，并重写Thread类的run方法
    2.将类申明实现Runnable接口，并实现Runnable接口里的run方法
    
    Runnable接口的好处：
    1.由于一个类只能继承一个类，当使用Runnable接口时，该类还能继承其他的类
    2.由于接口的性质，增强了程序的扩展性
        Runnable接口里的run方法只规定了线程的任务
        若要生成新线程并启动线程，则还需要调用Thread里的方法
# 7.线程补充
    1.每个线程在内存中都是一个单独的栈内存(t1.run()和t1.start()的区别),见Thread.MultiThread;
    
# 8.通过匿名内部类创建线程类的实例对象
    1.new Thread(){
        
        @override
        public void run(){
        
        }
    }.start;
    
    2.new Runable(){
              
        @override
        public void run(){
              
        }
     }.start;

# 9.线程安全
    1.什么是线程安全
    假如有个电影院，有10张票，现有1个售票窗口售票，要看电影都得到这个窗口排队买票，来一个人就少一张票，剩余的票数是不会出差错的，此时就可以理解为线程安全的；
    后来开通了3个窗口，也是卖10张票，这时就会出现一个问题，假如第一个窗口售出一张票，一号窗口就会显示余票是9，但是2,3窗口的余票却还显示的10，最后出现的问题是，票已售空，但是余票不为空，此时就是线程不安全的
    
    多线程访问共享数据时，就会出现线程安全问题
    
    线程安全问题见Thread.ThreadSafe;
 
# 10.解决线程安全问题
    1.synchronized关键字
    作用是同步代码块，将被修饰的代码块分配一个对象锁
    
    1.1用synchronized创建一个锁对象：
        synchronized(obj)
    2.2用synchronized修饰方法
    
    2.静态代码块
    
    3.Lock锁

# 11.线程状态
    1.New(新建状态)
    new Thread()
    2.Runnable(运行状态)
    当线程对象调用start()方法后，开始抢占CPU，抢到CPU并开始执行线程任务的状态
    2.1当调用sleep(ms)或者wait(ms)方法后，会进入休眠状态，休眠时间结束后若CPU空闲则进入运行状态，否则则阻塞
    2.2当调用Object.wait()时，进入等待状态，调用Object.notify()进行唤醒
    3.Blocked(阻塞状态)
    当线程对象调用start()方法后，开始抢占CPU，没抢到CPU的状态
    4.Terminated(死亡状态)
    调用stop()方法
#### 为什么wait()、notify()和notifyAll()方法为什么属于Object？
    因为Java中，任何对象都可以作为锁，既然wait是放弃对象锁，当然就要把wait定义在这个对象所属的类中，由于所有类都继承于Object，我们完全可以把wait方法定义在Object类中，这样，当我们定义一个新类，并需要以它的一个对象作为锁时，不需要我们再重新定义wait方法的实现，而是直接调用父类的wait(也就是Object的wait)，此处，用到了Java的继承
# 12.线程通信
    生产者消费者问题
