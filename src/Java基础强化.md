### 1.Java基本数据类型的装换关系
    1.低容量  ------------------------------------>  高容量
      
      byte,short,char—> int —> long—> float —> double 
    2.byte a = 1;
      int b = 1;
      byte c;
      int d;
      
      d=a;将低容量类型的值赋值给高容量类型时，系统会自动转换（大吃小可以）
      c=b;将高容量类型的值赋值给低容量类型时，会报错，要强转c=(byte) b;(小吃大不行)
      
### 2.Java基本类型为什么要有其对应的包装类型
    1.Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。
    2.Java基本类型放在jvm的栈内存中，包装类型放在jvm堆内存中
    3.jvm提供了自动拆箱，装箱的机制     
      
### 3.访问修饰符的种类，以及作用范围
    1.public,protected,不写(default),private
    2.public作用方位最广，同包的和不同的类都能访问
    3.protected其次，只能同包的类访问
    4.不写(default)也只能同包的类访问，但是被该修饰符修饰的类，其子类不能访问
    5.private只能同类中访问
    
### 4.为什么说Java只有值传递？
    首先理解值传递，当调用一个函数传递参数时，函数的形参实际接收到的是实参的复制品，当函数的形参是数值的时候，接收到的是实参的复制品，无论函数怎么对形参做改变，实参都不会变；当函数的形参是引用型的参数时，其实接收到的也是实参的复制品，只不过是实参地址的复制品，此时形参和实参都指向堆内存中共同的对象，为什么改变函数里的形参，实参也会跟着改变呢？因为此时堆内存中的对象是共享的，函数的形参接收到了对象的地址，也指向了该对象，既然是共享对象，只要一方改变这个对象，另一方自然指向已经改变了的对象。
      
### 5.&和&&，|和||,^
    1.&和&&
    &:
    a.按位与（有 0 则为 0）
        对二进制数进行运算时，同一位置的数都为1时，该位置也为1，否则为0
    b.逻辑与
        对于一个判断式子（a&b）,此时需要对两者进行判断，注意，是对a和b都要进行判断，当都为真时再进行该条件后的操作
    &&：
    逻辑与
        对于一个判断式子（a&&b），当a为false时，则返回false，&&也成短路运算，只有a为true时才能判断b，否则直接返回false
    &和&&的区别：
        一个是都要判断，一个是短路运算
>        
    2.|和||    
    |:
    按位或：（有 1 则为 1）
    
    ||:
    逻辑或运算：对于一个判断式子（a&&b），有都要进行判断，有true就返回true       
>
    3.^
    按位异或运算：相同为0，不同为1
    
### 6.break、continue和return

### 7.面向对象的特征
    1.抽象
    
    2.封装
    
    3.继承
    
    4.多态
    
### 8.重载(overload)和重写(override)
    1.共同点
    都是实现多态的方式
>    
    2.不同点
    2.1重载(overload)
        a.实现的是编译时的多态，即写的代码到装换到*.class的过程中发生的
        b.发生在同一个类中，同类出现同名方法时，需要通过改变参数的个数、参数的类型和方法修饰的修饰符
    2.2重写(override)
        a.实现的是运行时的多态，即将*.class文件加载到jvm虚拟机之后，并且达到了运行时期
        b.发生在父类与之类之间，并且子类的方法修饰符的可见度范围不能比父类的方法的修饰符可见度小

### 9.String、StringBuilder和StringBuffer

### 10.           
