###  1. Java基本数据类型的装换关系

    1.低容量  ------------------------------------>  高容量
      
      byte,short,char—> int —> long—> float —> double 
      1		2		2	4		8		4		8
    2.byte a = 1;
      int b = 1;
      byte c;
      int d;
      
      d=a;将低容量类型的值赋值给高容量类型时，系统会自动转换（大吃小可以）
      c=b;将高容量类型的值赋值给低容量类型时，会报错，要强转c=(byte) b;(小吃大不行)

### 2. Java基本类型为什么要有其对应的包装类型

    1.Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。
    2.Java基本类型放在jvm的栈内存中，包装类型放在jvm堆内存中
    3.jvm提供了自动拆箱，装箱的机制     

### 3. 访问修饰符的种类，以及作用范围

    1.public,protected,不写(default),private
    2.public作用方位最广，同包的和不同的类都能访问
    3.protected其次，只能同包的类访问
    4.不写(default)也只能同包的类访问，但是被该修饰符修饰的类，其子类不能访问
    5.private只能同类中访问

### 4. 为什么说Java只有值传递？

    首先理解值传递，当调用一个函数传递参数时，函数的形参实际接收到的是实参的复制品，当函数的形参是数值的时候，接收到的是实参的复制品，无论函数怎么对形参做改变，实参都不会变；当函数的形参是引用型的参数时，其实接收到的也是实参的复制品，只不过是实参地址的复制品，此时形参和实参都指向堆内存中共同的对象，为什么改变函数里的形参，实参也会跟着改变呢？因为此时堆内存中的对象是共享的，函数的形参接收到了对象的地址，也指向了该对象，既然是共享对象，只要一方改变这个对象，另一方自然指向已经改变了的对象。

### 5. &和&&，|和||,^

    1.&和&&
    &:
    a.按位与（有 0 则为 0）
        对二进制数进行运算时，同一位置的数都为1时，该位置也为1，否则为0
    b.逻辑与
        对于一个判断式子（a&b）,此时需要对两者进行判断，注意，是对a和b都要进行判断，当都为真时再进行该条件后的操作
    &&：
    逻辑与
        对于一个判断式子（a&&b），当a为false时，则返回false，&&也成短路运算，只有a为true时才能判断b，否则直接返回false
    &和&&的区别：
        一个是都要判断，一个是短路运算
        
    2.|和||    
      |:
      按位或：（有 1 则为 1）
      ||:
      逻辑或运算：对于一个判断式子（a&&b），有都要进行判断，有true就返回true
      
    3.^
      按位异或运算：相同为0，不同为1  

### 6. break、continue和return

### 7. 面向对象的特征

```md
1.抽象

2.封装

3.继承

4.多态
```

### 8. 重载(overload)和重写(override)

```md
1.共同点
都是实现多态的方式
2.不同点
  2.1重载(overload)
      a.实现的是编译时的多态，即写的代码到装换到*.class的过程中发生的
      b.发生在同一个类中，同类出现同名方法时，需要通过改变参数的个数、参数的类型,方法类型可以相同可以不同，重点在于参数
  2.2重写(override)
      a.实现的是运行时的多态，即将*.class文件加载到jvm虚拟机之后，并且达到了运行时期
      b.发生在父类与之类之间，并且子类的方法修饰符的可见度范围不能比父类的方法的修饰符可见度小
```

### 9. String、StringBuilder和StringBuffer

### 10. 抽象类和接口的区别

~~~md
1.抽象类是单继承，接口可以多继承；
2.抽象类声明式abstract，接口是interface；
3.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型；
4. 抽象类中可以包含静态方法，接口中不能包含静态方法；
5.抽象类可以有构造方法，接口中不能有构造方法；
6.抽象类中可以有普通成员变量，接口中没有普通成员变量；
7.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法；
8.抽象类中的抽象方法的访问类型可以是public，protected和默认类型，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型
~~~

### 11.JDK1.7和JDK1.8，HashMap的变化

~~~md
1.resize 扩容优化
2.解决了resize时多线程死循环问题（头插和尾插）
	头插：定位，头插，移位
3.引入了红黑树，目的是避免单条链表过长而影响查询效率
~~~

### 12.Error和Exception的区别

~~~md



常见异常：
	1.npe（空指针异常）
		所访问的数组已经不在指向堆内存，如果继续访问该数组，则会报该异常
	2.ArrayIndexOutOfBoundsException（数组元素超出）
		访问的元素下标超过数组的实际下标
~~~

### 13. Dao层，Service层，Controller层

~~~md
1.Dao层：全称Data Access Object。Dao层比较底层，负责与数据库打交道具体到对某个表、某个实体的增删改查
2.Service层：又叫服务层或业务层，封装Dao层的操作，使一个方法对外表现为实现一种功能，例如：网购生成订单时，不仅要插入订单信息记录，还要查询商品库存是否充足，购买是否超过限制等等。
3.Controller层：业务控制层，负责接收数据和请求，并且调用Service层实现这个业务逻辑。

Controller层像是一个服务员，他把客人（前端）点的菜（数据、请求的类型等）进行汇总什么口味、咸淡、量的多少，交给厨师长（Service层），厨师长则告诉沾板厨师（Dao 1）、汤料房（Dao 2）、配菜厨师（Dao 3）等（统称Dao层）我需要什么样的半成品，副厨们（Dao层）就负责完成厨师长（Service）交代的任务。
~~~

### 14.sleep和wait的区别？

~~~md
    1.两者最主要的区别在于：sleep() 方法没有释放锁，而 wait() 方法释放了锁 。
    2.两者都可以暂停线程的执行。
    3.wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行。
    4.wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。

~~~

### 15. JDK1.7和JDK1.8中，hashmap的区别？

~~~md
1.从添加数据(包括扩容后，将数据从旧的hashmap中转移到一个新的hashmap中)方面来讲：JDK1.7中采用的是头插法，JDK1.8采用的尾插法，这样的目的是为了避免出现闭环的情况

2.在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容

3.从采用的数据结构来讲：JDK1.7中采用的是数组+链表，JDK1.8中，当链表的深度小于8，且数组长度小于64时，采用的是数组+链表，否则就会将链表转换为红黑树

4.扩容后数据储存位置的计算方式，JDK1.7全部按照原来的方法进行计算()，JDK1.8则是按照扩容后的规律进行计算(将每个元素与扩容后数组长度-1进行&运算，高位为0则将其放在原来的位置，为1则是原位置的索引+旧数组容量)

5.计算key值的hash值时，JDK1.7用了9次扰动处理=4次位运算+5次异或，而JDK1.8只用了2次扰动处理=1次位运算+1次异或

~~~

