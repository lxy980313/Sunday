# 1.集合学习目标
    1.掌握每种集合的特性
    2.了解每种集合的底层原理
    3.掌握使用集合存储数据（存放数据）
    4.掌握每种集合的遍历方法（迭代器）
---
# 2.集合概述
    Collection:
                1 List
                    1.1 ArrayList
                    1.2 LinkedList
                    1.3 Vector
                2 Set
                    2.1 HashSet
                        2.1.1 LinkedHashSet
                    2.2TreeSet
---
## 2.1集合里涉及到的数据结构
栈、队列、数组、链表和红黑树

    1.数组
    创建一个数组时，计算机在内存中分配一块区域，该区域的内存地址放在头部，数组的长度就代表该区域被分为多少个小区域
    例如：int[] arr = new int[3];
    1.1 new int[3];
    在内存中取一块区域，并赋予地址，将该区域划分为三个挨着的区域
    1.2 int[] arr
    此时只是个引用
    1.3 int[] arr = new int[3]
    将地址赋予给arr，arr指向该区域
    
    2.链表
    链表由若干节点组成，节点为内存中随机的一块区域，每个节点由三部分组成，头部用于存放本节点的地址，躯干用于存放本节点的内容，尾部用于存放下一个节点的地址
    
    3.红黑树
    红黑树是一种自平衡的二叉查找树
    性质1. 节点是红色或黑色。
    性质2. 根节点是黑色。 
    性质3.所有叶子都是黑色。（叶子是NIL节点） 
    性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）
    性质5.. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 
    即红黑树自平衡的方式有两种，变色和旋转
    
    若添加的节点的父节点为黑色节点，树保持不变
    若添加的节点的父节点和叔叔节点都为红色，则将父节点和叔叔节点变黑，祖父节点变红，然后再对照要求接着变换​    
---
## 2.2 Iterator
见Collection.Iterator

    1.Iterator接口就是迭代器接口，提供了一种遍历方式,Iterator<Integer> iterator = 集合名.iterator();
    2.增强for循环，底层也是迭代器
        for (集合/数组的数据类型 变量名 : 集合名/数组名){
                    
                }
        注意，增强for只能遍历集合或数组
---
## 2.3 泛型
```md
1.有个柜子，可以用来存放衣服、鞋子或者杂物，当我们往里存放衣服的时候，这个柜子就是衣柜，存放鞋子的时候，就是鞋柜，存放杂物的时候，就是杂物柜，只有当我们往里放东西的时候，才能决定这个柜子是衣柜还是鞋柜
2.在Java中有一种数据类型就类似于上述例子的柜子，这种数据类型就是泛型  
```
---
## 2.4 List
### 1.ArrayList
    ArrayList底层是用数组实现的，可以认为ArrayList是一个可改变大小的数组。随着越来越多的元素被添加到ArrayList中，其规模是动态增加的,即每次增删都是创建新的数组拷贝值，故其特性是：查快改慢
### 2.LinkedList
    LinkedList底层是通过双向链表实现的。由于没有索引，其特性是：查慢改快
以上两种非线程安全
### 3.Vector
    可以理解为线程安全版的ArrayList
---
## 2.5 Set
什么是哈希表？
    
    由Node数组+链表构成的一种数据结构
    Node数组用于存放对应的键值对，哈希值是通过实际地址用某种方法计算出的一种十进制值；
    当哈希值相同而类容又不同时，则将其放入链表，当链表容器超过规定数值时，会变成红黑树结构
---
### 1.HashSet
    无序且不允许重复储存元素
#### 1.1LinkedList
    结构为哈希表+链表
    有序且不允许重复储存元素，此处的有序指的是储存顺序（存入的顺序和取出的顺序），并不是排序顺序
#### 1.2用HashSet存储元素，在保证元素唯一为什么要重写equal（）和hashCode（）？
    首先HashSet的底层原理是哈希表，哈希表是由数组和链表组成的；一个元素存入哈希表的过程包括，计算哈希值，再通过偏移计算出该元素在哈希表储存的位置，在储存的过程中，先看该位置有没有元素，没有元素就添加，若有元素则比较哈希值，哈希值不同也储存，若哈希值相同则元素的内容，内容不同也储存，若内容相同则不储存。若HashSet里有两个相同的元素，则说明他们满足存入哈希表的原理，则需要重写equal（）和hashCode（）方法来辨别。
    
      引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode方法，会得到相同的结果，如果对象所属的类没有覆盖Object的hashCode方法的话，hashCode会返回每个对象特有的序号（java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashCode值是不可能相等的。
    
    如果想要让两个不同的Person对象视为相等的，就必须覆盖Object继下来的hashCode方法和equals方法，因为Object  hashCode方法返回的是该对象的内存地址，所以必须重写hashCode方法，才能保证两个不同的对象具有相同的hashCode，同时也需要两个不同对象比较equals方法会返回true
### 2.TreeSet
    用TreeSet存储数据后，数据会被排序

# 3. Map
底层由哈希表实现
## 1.特点
    1.Map<key, value>集合是一个双列集合，一个元素包含两个值，key和value
    2.Map<key, value>集合中，key和value的类型不能是基本数据类型，可以自由组合
    3.一个Map集合中，有且只有一个key，但是可以有多个相同的value
    4.key和value是一一对应的，一个key只能对应一个value
## 2.HashMap
    1.不能保证集合中元素的顺序不变
    2.非线程安全

## 3.LinkedHashMap
    1.结构为哈希表+链表，故能够记录元素加入的顺序

## 4.TreeMap
    用TreeMap存储数据后，数据会被排序
## 5.HashTable
    线程安全版的HashMap，与HashMap不同的是，HashTable里不允许任何null值的出现
## 5.常用方法及注意点
    见package Collection.Map;

# 4.HashMap原码解析
## 4.1构造方法
    1.public HashMap()
        注意，使用HashMap<?,?> hm = new HashMap<>()时，实际上是一个空的节点数组，在第一次使用put时才会进行扩容
    2.public HashMap(int initialCapacity)
    
    3.public HashMap(int initialCapacity, float loadFactor)
    
    4.public HashMap(Map<? extends K, ? extends V> m)
## 4.2成员变量
    1.DEFAULT_INITIAL_CAPACITY //初始节点数组的容量
    2.MAXIMUM_CAPACITY //数组节点的最大容量
    3.DEFAULT_LOAD_FACTOR //默认加载因子
    4.TREEIFY_THRESHOLD //数组某个索引处，节点形成的链表转换为红黑树的阈值
    5.UNTREEIFY_THRESHOLD //数组某个索引处，若该节点是红黑树，则红黑树变成链表的阈值
    6.MIN_TREEIFY_CAPACITY //链表转换为红黑树除了链表长度达到阈值外，还需要节点数组的容量达到转换阈值
    7.float loadFactor //自定义加载因子
    8.threshold //节点数组扩容的阈值，节点数组容量*加载因子
    9.modCount //节点数组更改次数
    10.size //节点数组已使用的数量
    11.entrySet
    12.Node<K,V>[] table //空数组
## 4.3关于Key的索引计算公式（(length - 1) & hash
详细见4.4成员方法之put

    在原码中发现，key的索引是通过(length - 1) & hash计算而得出的，虽然和取余的效果一样，但是实际上取余比较耗资源，length为该HashMap的结构中数组的初始长度，当创建一个无参的HashMap时，默认数组容量为16
    而此时的hash值并不是指的通过地址计算得到的hash值，而是通过((h = key.hashCode()) ^ (h >>> 16))

## 4.4为什么HashMap的结构中数组的初始长度length必须是2的n次幂？
    首先，这样的目的是为了减少哈希碰撞
    按位与&：相同位数上都为1时，结果为1，否则为0
    按位异或^:
#### 数组长度为2^n(假设n=3)次幂时，假定任意哈希值
    哈希值3:0000 0011
    数组长度8:0000 1000
    (length - 1)=7:0000 0111
    3 & (8 - 1)
        0000 0011
        0000 0111
    -------------
        0000 0011  3
    所以索引为3    


    哈希值2:0000 0010
    数组长度8:0000 1000
    (length - 1)=7:0000 0111
    3 & (8 - 1)
        0000 0010
        0000 0111
    -------------
        0000 0010  2
    所以索引为2

#### 数组长度不为2^n次幂时，假设长度为9

    哈希值3:0000 0011
    数组长度9:0000 1001
    (length - 1)=8:0000 1000
    3 & (8 - 1)
        0000 0011
        0000 1000
    -------------
        0000 0000  0
    所以索引为0


    哈希值2:0000 0010
    数组长度9:0000 1001
    (length - 1)=8:0000 1000
    3 & (8 - 1)
        0000 0010
        0000 1000
    -------------
        0000 0000  0
    所以索引为0    

不难发现出，不为2^n次幂时，不会均匀分配，当初始容量不为2^n次幂时，会将离该值最近的(2^n-1)赋值给初始值
>    static final int tableSizeFor(int cap) {
         int n = cap - 1;   //没有这步，若cap为2^n次幂，理应不会改变，但是经过计算会*2
         n |= n >>> 1;
         n |= n >>> 2;
         n |= n >>> 4;
         n |= n >>> 8;
         n |= n >>> 16;
         return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
     }

## 4.5扩容机制
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    
    当存放索引的数组里存放的元素达到：数组长度 * 加载因子(LOAD_FACTOR)时，则扩容

>LOAD_FACTOR加载因子补充

    1.用来衡量HashMap满的程度，表示疏密度，影响每个元素hash操作后，放在同一个数组位置的概率
    2.计算方式：数组实际元素个数/数组长度
    3.介于0~1直接
        太大会影响元素查找效率，即哈希碰撞概率会变大
        太小会影响数组利用率
        所以0.75f是官方给的一个比较好的临界值
    4.当数组里的存放的数快达到75%时，则扩容数组

#### 扩容时，新建哈希表，将原来的数据重新计算哈希值并放入新的哈希表，所以扩容非常耗资源，jdk8后哈希表的性能是接近于完美的

## 4.6成员方法

### 1.put方法 
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                       boolean evict) {
                       
    }
    
    static final int hash(Object key) {
        int h;
        //HashSet不能存放null和HashMap的Key能为null在于HashMap考虑了为null的情况
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }   
#### 1.1解析 hash=(h = key.hashCode()) ^ (h >>> 16)和tab[i = (n - 1) & hash]
*   h = key.hashCode()
    
    根据地址计算得到一个散列值(hashCode)，该数值比较大，假设计算的hashCode值为：1111 1111 1111 1111 1111 0000 1110 1010
*   h >>> 16
--------------------
    0000 0000 0000 0000 1111 1111 1111 1111
    h >>> 16的目的是为了减少哈希冲突  

*   (h = key.hashCode()) ^ (h >>> 16)
-------------------------------------
        1111 1111 1111 1111 1111 0000 1110 1010     h    
    ^   0000 0000 0000 0000 1111 1111 1111 1111     h >>> 16
    -----------------------------------------------------
    	1111 1111 1111 1111 0000 1111 0001 0101     返回结果 
*   tab[i = (n - 1) & hash]
----------------------
        1111 1111 1111 1111 0000 1111 0001 0101     hash
    &   0000 0000 0000 0000 0000 0000 0000 1111     (n-1)   16-1
    -------------------------------------------------------------
        0000 0000 0000 0000 0000 0000 0000 0101     索引值

#### 1.2putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)方法的主要参数
    1.int hash
        key的哈希值
    2.K key
        传进来的key值
    3.V value
        key对应的value
    4.boolean onlyIfAbsent
        如果为true代表不更改现有值
    5.boolean evict
        如果为false表示table为创建状态        
#### 1.3putVal()方法的成员变量
    Node<K,V>[] tab; //创建一个空的节点数组
    Node<K,V> p; //创建一个空节点
    int n, i; //i表示节点数组的索引，n用于接收节点数组的长度
#### 1.4putVal()方法的流程图
    //调用HashMap的无参构造方法时，会先执行该语句，对节点数组进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
                  n = (tab = resize()).length;
---
    //当执行put方法时，会发现此语句的目的除了进行判断数组索引处的节点是否为空外，还有就是将p指向该节点，后面当出现哈希碰撞时，还会有一个e指向p.next，由于链表的特性，通过遍历来改变指向
    if ((p = tab[i = (n - 1) & hash]) == null)
---
![](E:\IdeaProject\Sunday\src\Collection\putVal.png)

#### 1.4resize()方法
    int oldCap; //旧节点数组的容量
    int oldThr; //旧节点数组的阈值
    int newCap, newThr = 0; //新节点数组的容量和阈值
---
    注意到源码中，扩容的方法是final Node<K,V>[] resize()，说明该方法返回的是一个节点数组，而且扩容的本质就是创建一个比旧数组容量大两倍的新数组，同过规则将旧数组的元素搬到新数组中
    原理如下：
    1.遍历旧数组的每个索引位置的节点是否为空节点，是则不搬动看下一位
    2.若旧数组索引处的节点不为空节点，且其没有后续节点，则同过高低位对比
    3.若旧数组索引处的节点不为空节点，有后续节点且为红黑树，则拆分红黑树
    4.若旧数组索引处的节点不为空节点，有后续节点但不是红黑树，则通过高低位对比
    索引变化的规律：
    判断该节点hash值的高位是0还是1
    若高位为1，则新数组索引=旧数组索引+旧数组长度
    若高位为0，则新数组索引=旧数组索引
### 2.remove方法
### 3.get方法
### 4.HashMap的遍历
    见Collection.Map;

