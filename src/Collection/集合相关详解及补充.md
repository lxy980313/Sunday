# 1.集合学习目标
    1.掌握每种集合的特性
    2.了解每种集合的底层原理
    3.掌握使用集合存储数据（存放数据）
    4.掌握每种集合的遍历方法（迭代器）
---
# 2.集合概述
    Collection:
                1 List
                    1.1 ArrayList
                    1.2 LinkedList
                    1.3 Vector
                2 Set
                    2.1 HashSet
                        2.1.1 LinkedHashSet
                    2.2TreeSet
---                    
## 2.1集合里涉及到的数据结构
栈、队列、数组、链表和红黑树

    1.数组
    创建一个数组时，计算机在内存中分配一块区域，该区域的内存地址放在头部，数组的长度就代表该区域被分为多少个小区域
    例如：int[] arr = new int[3];
    1.1 new int[3];
    在内存中取一块区域，并赋予地址，将该区域划分为三个挨着的区域
    1.2 int[] arr
    此时只是个引用
    1.3 int[] arr = new int[3]
    将地址赋予给arr，arr指向该区域
    
    2.链表
    链表由若干节点组成，节点为内存中随机的一块区域，每个节点由三部分组成，头部用于存放本节点的地址，躯干用于存放本节点的内容，尾部用于存放下一个节点的地址
    
    3.红黑树
    红黑树是一种自平衡的二叉查找树
    性质1. 节点是红色或黑色。
    性质2. 根节点是黑色。 
    性质3.所有叶子都是黑色。（叶子是NIL节点） 
    性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）
    性质5.. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 
    即红黑树自平衡的方式有两种，变色和旋转
    
    变色：
    如果当前节点的父亲节点和叔叔节点均是红色，那么执行以下变色操作：
        父 --> 黑
        叔 --> 黑
        爷 --> 红
        开始分析爷爷是否满足红黑树特性
        
    左旋
        条件：
        父亲是红色
        叔叔是黑色
        当前是右子树
    
        执行：
        已父亲进行旋转
        
        
    右旋   
        条件：
        父亲是红色
        叔叔是黑色
        当前是左子树
    
        执行：
        父亲节点 变为 黑色
        爷爷节点变为红色
        再已爷爷节点进行旋转
---
## 2.2 Iterator
见Collection.Iterator

    1.Iterator接口就是迭代器接口，提供了一种遍历方式,Iterator<Integer> iterator = 集合名.iterator();
    2.增强for循环，底层也是迭代器
        for (集合/数组的数据类型 变量名 : 集合名/数组名){
                    
                }
        注意，增强for只能遍历集合或数组
---
## 2.3 泛型
    1.有个柜子，可以用来存放衣服、鞋子或者杂物，当我们往里存放衣服的时候，这个柜子就是衣柜，存放鞋子的时候，就是鞋柜，存放杂物的时候，就是杂物柜，只有当我们往里放东西的时候，才能决定这个柜子是衣柜还是鞋柜
    2.在Java中有一种数据类型就类似于上述例子的柜子，这种数据类型就是泛型  
---
## 2.4 List
### 1.ArrayList
    ArrayList底层是用数组实现的，可以认为ArrayList是一个可改变大小的数组。随着越来越多的元素被添加到ArrayList中，其规模是动态增加的,即每次增删都是创建新的数组拷贝值，故其特性是：查快改慢
### 2.LinkedList
    LinkedList底层是通过双向链表实现的。由于没有索引，其特性是：查慢改快
以上两种非线程安全
### 3.Vector
    可以理解为线程安全版的ArrayList
---
## 2.5 Set
什么是哈希表？
    
    由数组+链表构成一种数据结构
    数组用于存放哈希值，哈希值是通过实际地址用某种方法计算出的一种十进制值；
    当哈希值相同而类容又不同时，则将其放入链表，当链表容器超过规定数值时，会变成红黑树结构
    
### 1.HashSet
    无序且不允许重复储存元素
#### 1.1LinkedList
    结构为哈希表+链表
    有序且不允许重复储存元素，此处的有序指的是储存顺序（存入的顺序和取出的顺序），并不是排序顺序
#### 1.2用HashSet存储元素，在保证元素唯一为什么要重写equal（）和hashCode（）？
    首先HashSet的底层原理是哈希表，哈希表是由数组和链表组成的；一个元素存入哈希表的过程包括，计算哈希值，再通过偏移计算出该元素在哈希表储存的位置，在储存的过程中，先看该位置有没有元素，没有元素就添加，若有元素则比较哈希值，哈希值不同也储存，若哈希值相同则元素的内容，内容不同也储存，若内容相同则不储存。若HashSet里有两个相同的元素，则说明他们满足存入哈希表的原理，则需要重写equal（）和hashCode（）方法来辨别。
### 2.TreeSet
    用TreeSet存储数据后，数据会被排序
    
# 3.Map
底层由哈希表实现
## 1.特点
    1.Map<key, value>集合是一个双列集合，一个元素包含两个值，key和value
    2.Map<key, value>集合中，key和value的类型不能是基本数据类型，可以自由组合
    3.一个Map集合中，有且只有一个key，但是可以有多个相同的value
    4.key和value是一一对应的，一个key只能对应一个value
## 2.HashMap
    1.不能保证集合中元素的顺序不变
    2.非线程安全
   
## 3.LinkedHashMap
    1.结构为哈希表+链表，故能够记录元素加入的顺序
   
## 4.TreeMap
    用TreeMap存储数据后，数据会被排序
## 5.HashTable
    线程安全版的HashMap，与HashMap不同的是，HashTable里不允许任何null值的出现
## 5.常用方法及注意点
    见package Collection.Map;
